# pers.bczl.se.jvm
初步了解JVM结构。
## JVM结构

* Class文件
* 类加载器子系统
* 运行时数据区
* 执行引擎
* 本地方法接口
* 本地方法库

## 运行时数据区

运行时数据区包括：
> 方法区
>> 堆
>>> 栈
>>>> PC寄存器
>>>>> 本地方法


## 1．方法区：


和Java堆一样，方法区是一块所有线程共享的内存区域，用于保存系统的类信息，(类的信息：字段、方法、常量池)。方法区也有一块内存区域所以方法区的内存大小，决定了系统可以包含多少个类，如果系统类太多，方法区内存不够肯定会导致方法区溢出，虚拟机同样会抛出内存溢出信息。(内存溢出后面相关文章给大家总结)
jdk6和jdk7中，方法区可以理解为永久区(Perm).永久区可以使用参数-XX:PermSize和-XX:MaxPermSize制定。默认情况下-XX:MaxPermSize为64MB.如果你项目中使用代理模式或者CGLIB的话可能在运行的时候生成大量的类，如果这样，需要设置一下永久区的大小，防止永久区内存溢出
对象实例化，类的字段、方法、常量池保存在方法区，因此操作会占用一定内存的

注意一点：
jdk8中永久区被移除了，取而代之的是元数据区，可能方法区依赖jvm的内存吧。元数据区可以使用-XX:MaxMetaspaceSize制定，跟之前版本的-XX:MaxPermSize一样，分配的值越多，就可以支持更多的类。不同的是元数据区是堆外直接内存，与方法永久区不同，在不指定大小的情况下，虚拟机会耗尽所有可用的系统内存。
元数据区发生溢出，虚拟机一样抛出异常，如下：
java.lang.OutOfMemoryError Metaspace

## 2.堆：


1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)
2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本。
3.创建的对象信息将放入堆中，堆内部如何实现各虚拟机各不相同。
4.每个java应用进程（一个main线程以及它的子线程）对应一个堆，堆的大小可以通过参数-xms,-xmx来设置。 java中所有通过new出来的对象和数组都存在堆中，可以为各线程共享，堆中的内存空间通过垃圾回收器进行回收。


## 3.栈：

1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中
2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
4.栈是线程私有的，栈的生命周期就是线程的生命周期，可以通过-Xss来分配每个线程的栈空间，如果某个线程的栈空间不足，系统会抛StackOverFlowError异常。栈中是以栈帧为单位进行维护的，java中没调用以方法就会创建一个栈帧，用于存储局部变量区，操作数，等，所以可以说，java中方法的调用过程，其实就是对栈的操作过程（分为压栈和出栈）。基本类型（如short,int...）和对象的引用的保存在栈中，由于这些数据都有已知的固定的大小，栈中的存取速度较快，栈还有一个特点，就是存在栈中的数据可以共享，而堆却不可以，共享的意思就是讲相同的数据可以共用同一内存块。
5.对于每个执行线程，会分配一个Java栈，JVM在执行过程当中，每执行一个方法，都会为方法在当前栈中增加一个栈帧，每个栈帧的信息与具体实现相 关，但一般会由3部分组成：变量区，方法参数和本地变量会放入这个位置，大小是固定的，在进行方法时会先分配好，在类定义中，会由max local来指定这块区的大小；方法信息区，会包括当前类常量池的入口地址等信息，这块大小也是固定的；操作栈，与Intel体系架构中的运算使用寄存器 来进行不一样，JVM的字节码的方法调用、运算等需要的参数，都是通过操作栈来传递的，在后面详细介绍中我们会进一步了解到，在类定义中，会由max stack指定最大的操作栈。关于Java栈的更详细描述参见《Java 栈内存介绍 》


## 4.PC寄存器：

1.每个线程启动的时候，都会创建一个PC（Program Counter，程序计数器）寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。 每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。保存下一条将要执行的指令地址的寄存器是 ：PC寄存器。PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。


## 5.本地方法栈：

1.对本地方法的调用，并不会使用Java栈而是使用本地方法栈，本地方法栈的组成取决于所使用的平台和操作系统。
