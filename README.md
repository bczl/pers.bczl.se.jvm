# pers.bczl.se.jvm
初步了解JVM结构。
## JVM结构

* Class文件
* 类加载器子系统
* 运行时数据区
* 执行引擎
* 本地方法接口
* 本地方法库

## 一：运行时数据区

运行时数据区包括：
> 方法区
>> 堆
>>> 栈
>>>> PC寄存器
>>>>> 本地方法


#### 1．方法区：


* 1.和Java堆一样，方法区是一块所有线程共享的内存区域，用于保存系统的类信息，(类的信息：字段、方法、常量池)。方法区也有一块内存区域所以方法区的内存大小，决定了系统可以包含多少个类，如果系统类太多，方法区内存不够肯定会导致方法区溢出，虚拟机同样会抛出内存溢出信息。
* 2.jdk6和jdk7中，方法区可以理解为永久区(Perm).永久区可以使用参数-XX:PermSize和-XX:MaxPermSize制定。默认情况下-XX:MaxPermSize为64MB.如果你项目中使用代理模式或者CGLIB的话可能在运行的时候生成大量的类，如果这样，需要设置一下永久区的大小，防止永久区内存溢出。
* 3.对象实例化，类的字段、方法、常量池保存在方法区，因此操作会占用一定内存的。
* 4.方法区是系统分配的一个内存逻辑区域，是用来存储类型信息的(类型信息可理解为类的描述信息)。方法区主要有以下几个特点： 
   一.方法区是线程安全的。由于所有的线程都共享方法区，所以，方法区里的数据访问必须被设计成线程安全的。例如，假如同时有两个线程都企图访问方法区中的同一个类，而这个类还没有被装入JVM，那么只允许一个线程去装载它，而其它线程必须等待 
   二.方法区的大小不必是固定的，JVM可根据应用需要动态调整。同时，方法区也不一定是连续的，方法区可以在一个堆(甚至是JVM自己的堆)中自由分配。 
   三.方法区也可被垃圾收集，当某个类不在被使用(不可触及)时，JVM将卸载这个类，进行垃圾收集 
* 5.方法区里存的都是类型信息，也就是类的信息，而类的信息又包括以下内容： 
     类的全限定名(类的全路径名) 
    类的直接超类的全限定名(如果这个类是Object,则它没有超类) 
    这个类是类型(类)还是接口 
     类的访问修饰符,如public、abstract、final等 
     所有的直接接口全限定名的有序列表(假如它实现了多个接口)
    
    其实，我们没必要全部记住，只要根据上面内容有个大概的了解，然后对类型这个概念有个大概的认识即可。下面我们将主要对常量池和类变量信息作一下分析。 
    先说类变量吧，类变量内容少些，描述起来比较容易。类变量，顾名思义，就是属于类的变量，所有类的实例都共享的变量，也就是常说的静态变量。关于类变量，我们只要知道方法区里有个静态区，静态区是专门用来存放静态变量以及静态块的。所有类的实例都共享方法区中的内容。访问类变量的方式可通过实例(对象)来访问，也可通过类型来直接访问，java规范推荐使用类型来直接访问。 

注意一点：
jdk8中永久区被移除了，取而代之的是元数据区，可能方法区依赖jvm的内存吧。元数据区可以使用-XX:MaxMetaspaceSize制定，跟之前版本的-XX:MaxPermSize一样，分配的值越多，就可以支持更多的类。不同的是元数据区是堆外直接内存，与方法永久区不同，在不指定大小的情况下，虚拟机会耗尽所有可用的系统内存。
元数据区发生溢出，虚拟机一样抛出异常，如下：
java.lang.OutOfMemoryError Metaspace

#### 常量池 :

   字段、方法信息、类变量信息(静态变量)   装载该类的装载器的引用(classLoader)、类型引用(class) 

#### 2. 堆：


* 1.存储的全部是对象，每个对象都包含一个与之对应的class的信息。(class的目的是得到操作指令)
* 2.jvm只有一个堆区(heap)被所有线程共享，堆中不存放基本类型和对象引用，只存放对象本。
* 3.创建的对象信息将放入堆中，堆内部如何实现各虚拟机各不相同。
* 4.每个java应用进程（一个main线程以及它的子线程）对应一个堆，堆的大小可以通过参数-xms,-xmx来设置。 java中所有通过new出来的对象和数组都存在堆中，可以为各线程共享，堆中的内存空间通过垃圾回收器进行回收。


#### 3. 栈：

* 1.每个线程包含一个栈区，栈中只保存基础数据类型的对象和自定义对象的引用(不是对象)，对象都存放在堆区中
* 2.每个栈中的数据(原始类型和对象引用)都是私有的，其他栈不能访问。
* 3.栈分为3个部分：基本类型变量区、执行环境上下文、操作指令区(存放操作指令)。
* 4.栈是线程私有的，栈的生命周期就是线程的生命周期，可以通过-Xss来分配每个线程的栈空间，如果某个线程的栈空间不足，系统会抛StackOverFlowError异常。栈中是以栈帧为单位进行维护的，java中没调用以方法就会创建一个栈帧，用于存储局部变量区，操作数，等，所以可以说，java中方法的调用过程，其实就是对栈的操作过程（分为压栈和出栈）。基本类型（如short,int...）和对象的引用的保存在栈中，由于这些数据都有已知的固定的大小，栈中的存取速度较快，栈还有一个特点，就是存在栈中的数据可以共享，而堆却不可以，共享的意思就是讲相同的数据可以共用同一内存块。
* 5.对于每个执行线程，会分配一个Java栈，JVM在执行过程当中，每执行一个方法，都会为方法在当前栈中增加一个栈帧，每个栈帧的信息与具体实现相 关，但一般会由3部分组成：变量区，方法参数和本地变量会放入这个位置，大小是固定的，在进行方法时会先分配好，在类定义中，会由max local来指定这块区的大小；方法信息区，会包括当前类常量池的入口地址等信息，这块大小也是固定的；操作栈，与Intel体系架构中的运算使用寄存器 来进行不一样，JVM的字节码的方法调用、运算等需要的参数，都是通过操作栈来传递的，在后面详细介绍中我们会进一步了解到，在类定义中，会由max stack指定最大的操作栈。关于Java栈的更详细描述参见《Java 栈内存介绍 》


#### 4. PC寄存器：

* 1.每个线程启动的时候，都会创建一个PC（Program Counter，程序计数器）寄存器。PC寄存器里保存有当前正在执行的JVM指令的地址。 每一个线程都有它自己的PC寄存器，也是该线程启动时创建的。保存下一条将要执行的指令地址的寄存器是 ：PC寄存器。PC寄存器的内容总是指向下一条将被执行指令的地址，这里的地址可以是一个本地指针，也可以是在方法区中相对应于该方法起始指令的偏移量。


#### 5. 本地方法栈：

* 1.对本地方法的调用，并不会使用Java栈而是使用本地方法栈，本地方法栈的组成取决于所使用的平台和操作系统。


## 二：类加载器子系统

* 1.类加载器完成类的加载工作，包括查找和装载类定义(.class)信息、连接（包括字节码验证、类变量内存分配和初始化、符号解析）和类初始化的过程
查找和装载类定义(.class)信息：关 于这块的内容可以google到无数的描述文档，JVM内部也提供了多种查找和装载类定义的途径，譬如从本地加载类定义、从远程加载类定义，甚至需要的 话，我们可以对类定义进行加密在装载的时候做处理等等，更详细的描述也可以参见《[Tomcat源码系列] Tomcat 类加载器结构 》
连接—字节码验证：对于加载的类定义，JVM必须确保其是合法的，包括定义的结构是合法的、声明的类信息（包括属性、方法等等）是合法的、字节码的正确性（包括确保操作码是合法的、有合法操作栈、goto语句能够到达一个合法的地址上等等）等等
连接—类变量内存分配和初始化：在这个阶段，类变量将分配内存，并设置一个合法的初始化值，譬如对象是null、数值型是0、布尔值是false等等
连 接—符号解析：符号定义了类提供给外部可访问的服务以及类需要访问到的外部的服务，譬如类提供了方法给外部调用，或者类调用外部的方法，这些就是符号，符 号解析过程就是将符号型的描述（譬如字符串）转换成实际的引用地址（譬如方法入口字节码指针地址），符号解析可能是在加载时进行，也有可能推迟到实际被使 用到才去解析，但不管怎么样，JVM应该对外提供迟解析的印象，即不管何时解析符号，总是在符号被第一次访问的时候才会抛出异常，关于符号解析，后面会有 专门的篇章更详细地介绍
类初始化：类的初始化是在类第一次被引用到的时候进行，类初始化包括给类属性(static)设置初始化值、调用类中的static块代码，在字节码中，会有一个专门的<clinit>方法，类初始化的时候会调用这个方法，譬如如下


## 三：执行引擎

* 1.可以理解为CPU，是JVM最核心的部分。在Java虚拟机规范中，执行引擎的行为使用指令集来定义。对于每条指令，规范都详细规定了当实现执行到该指令时应该处理什么，但却没有定义如何处理，具体策略交给JVM的具体实现。



## 四：Class文件

* 1.Java 字节码可以跨不同的虚拟机在不同的平台上执行，这些字节码按照class文件格式的规范组成了class文件，从而为Java语言跨平台执行奠定了基石； 不同的语言都可以根据class文件格式生成可以在JVM上执行的字节码，这又给Java平台带来了新的血液。
* 2.class 文件是Java程序二进制的精确定义 。每一个class文件都是对一个Java 类或者接口的描述。因为有着同一的格式，  无论在何种平台上产生，也无论是在何种平台上运行，class文件的定义都能够被Java虚拟机正确地读取。
* 3.一个典型的class文件分为：MagicNumber，Version，Constant_pool，Access_flag，This_class，Super_class，Interfaces，Fields，Methods 和Attributes这十个部分。


